---
alwaysApply: true
---

# Vue 3 前端项目规则

## 项目架构

- 基于 Vue 3 + Vite 的现代前端架构
- 使用 Composition API (setup 语法糖)
- Element Plus 作为 UI 组件库
- Pinia 作为状态管理
- Vue Router 4 作为路由管理
- Axios 作为 HTTP 请求库

## 项目结构规范

```
src/
├── api/              # API 接口定义
├── assets/           # 静态资源
│   ├── font/        # 字体文件
│   ├── img/         # 图片资源
│   ├── scss/        # 全局样式
│   └── svg/         # SVG 图标
├── components/       # 公共组件
├── router/          # 路由配置
├── stores/          # Pinia 状态管理
├── utils/           # 工具函数
├── views/           # 页面组件
├── App.vue          # 根组件
└── main.js          # 入口文件
```

## 编码规范

### 1. 组件命名规范

- 页面组件：使用 PascalCase，如 `Home.vue`, `ArticleDetail.vue`
- 公共组件：使用 PascalCase，如 `Header.vue`, `LoadingAnimation.vue`
- 组件文件夹：使用 PascalCase
- 路由名称：使用 camelCase

### 2. Vue 组件规范

- 统一使用 `<script setup>` 语法糖
- 模板中使用 kebab-case 属性名
- 组件 props 使用 camelCase
- 事件名使用 kebab-case
- 组件标签使用 PascalCase
- **⚠️ 重要：确保所有 HTML 标签都正确闭合，避免未闭合标签导致的页面渲染问题和布局错乱**

### 3. Composition API 规范

```vue
<script setup>
// 1. 导入依赖
import { ref, reactive, computed, onMounted } from "vue";
import { useRouter, useRoute } from "vue-router";
import { storeToRefs } from "pinia";

// 2. 定义 props 和 emits
const props = defineProps({
  title: String,
  data: Array,
});

const emit = defineEmits(["update", "delete"]);

// 3. 响应式数据
const isLoading = ref(false);
const formData = reactive({
  name: "",
  email: "",
});

// 4. 计算属性
const filteredData = computed(() => {
  return props.data?.filter((item) => item.active) || [];
});

// 5. 方法定义
const handleSubmit = () => {
  // 处理提交逻辑
};

// 6. 生命周期
onMounted(() => {
  // 初始化逻辑
});
</script>
```

### 4. 样式规范

- 使用 SCSS 预处理器
- 组件样式必须使用 `scoped`
- 全局样式变量定义在 `assets/scss/` 中
- 响应式设计使用媒体查询
- 颜色使用 CSS 变量或 SCSS 变量
- **📋 代码质量检查：编写完成后务必检查所有标签是否正确闭合，确保代码格式规范**

### 5. API 请求规范

```javascript
// api/article.js
import request from "@/utils/Request";

export const getArticleList = (params) => {
  return request({
    url: "/article/list",
    method: "get",
    params,
  });
};

export const createArticle = (data) => {
  return request({
    url: "/article/add",
    method: "post",
    data,
  });
};
```

### 6. 状态管理规范

```javascript
// stores/userStore.js
import { defineStore } from "pinia";
import { ref } from "vue";

export const useUserStore = defineStore(
  "user",
  () => {
    const user = ref(null);
    const token = ref(localStorage.getItem("token"));

    const setUser = (userData) => {
      user.value = userData;
    };

    const clearUser = () => {
      user.value = null;
      token.value = null;
      localStorage.removeItem("token");
    };

    return {
      user,
      token,
      setUser,
      clearUser,
    };
  },
  {
    persist: true, // 持久化存储
  }
);
```

### 7. 路由规范

```javascript
// router/index.js
import { createRouter, createWebHistory } from "vue-router";

const routes = [
  {
    path: "/",
    name: "Home",
    component: () => import("@/views/Home/index.vue"),
  },
  {
    path: "/article",
    name: "Article",
    component: () => import("@/views/Article/index.vue"),
    meta: {
      requiresAuth: true,
      title: "文章管理",
    },
  },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

// 路由守卫
router.beforeEach((to, from, next) => {
  // 权限验证逻辑
  next();
});

export default router;
```

### 8. 工具函数规范

- 工具函数使用纯函数
- 函数名使用 camelCase
- 添加 JSDoc 注释
- 导出使用具名导出

```javascript
// utils/formatTime.js
/**
 * 格式化时间
 * @param {Date|string} date 日期
 * @param {string} format 格式
 * @returns {string} 格式化后的时间
 */
export const formatTime = (date, format = "YYYY-MM-DD HH:mm:ss") => {
  // 实现逻辑
};
```

### 9. 组件通信规范

- 父子组件：props + emit
- 兄弟组件：使用 Pinia 状态管理
- 跨层级组件：provide/inject 或 Pinia
- 事件总线：避免使用，推荐 Pinia

### 10. 性能优化规范

- 使用 `v-memo` 缓存复杂计算
- 大列表使用虚拟滚动
- 图片懒加载
- 路由懒加载
- 组件懒加载使用 `defineAsyncComponent`

## Element Plus 使用规范

### 1. 组件使用

```vue
<template>
  <!-- 表单 -->
  <el-form :model="form" :rules="rules" ref="formRef">
    <el-form-item label="标题" prop="title">
      <el-input v-model="form.title" placeholder="请输入标题" />
    </el-form-item>
  </el-form>

  <!-- 表格 -->
  <el-table :data="tableData" stripe>
    <el-table-column prop="title" label="标题" />
    <el-table-column label="操作">
      <template #default="{ row }">
        <el-button type="primary" @click="handleEdit(row)">编辑</el-button>
      </template>
    </el-table-column>
  </el-table>

  <!-- 分页 -->
  <el-pagination v-model:current-page="currentPage" v-model:page-size="pageSize" :total="total" layout="prev, pager, next, sizes, total" @current-change="handlePageChange" />
</template>
```

### 2. 消息提示

```javascript
import { ElMessage, ElMessageBox } from "element-plus";

// 成功提示
ElMessage.success("操作成功");

// 确认对话框
ElMessageBox.confirm("确定要删除吗？", "提示", {
  confirmButtonText: "确定",
  cancelButtonText: "取消",
  type: "warning",
}).then(() => {
  // 确认操作
});
```

## 代码示例

### 完整页面组件示例

```vue
<template>
  <div class="article-list">
    <!-- 搜索表单 -->
    <el-form :model="searchForm" inline>
      <el-form-item label="标题">
        <el-input v-model="searchForm.title" placeholder="请输入标题" />
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="handleSearch">搜索</el-button>
        <el-button @click="handleReset">重置</el-button>
      </el-form-item>
    </el-form>

    <!-- 数据表格 -->
    <el-table v-loading="loading" :data="tableData" stripe>
      <el-table-column prop="title" label="标题" />
      <el-table-column prop="createTime" label="创建时间" />
      <el-table-column label="操作" width="200">
        <template #default="{ row }">
          <el-button type="primary" size="small" @click="handleEdit(row)"> 编辑 </el-button>
          <el-button type="danger" size="small" @click="handleDelete(row)"> 删除 </el-button>
        </template>
      </el-table-column>
    </el-table>

    <!-- 分页 -->
    <el-pagination v-model:current-page="pagination.pageNum" v-model:page-size="pagination.pageSize" :total="pagination.total" layout="prev, pager, next, sizes, total" @current-change="fetchData" @size-change="fetchData" />
  </div>
</template>

<script setup>
import { ref, reactive, onMounted } from "vue";
import { ElMessage, ElMessageBox } from "element-plus";
import { getArticleList, deleteArticle } from "@/api/article";

// 响应式数据
const loading = ref(false);
const tableData = ref([]);
const searchForm = reactive({
  title: "",
});
const pagination = reactive({
  pageNum: 1,
  pageSize: 10,
  total: 0,
});

// 方法
const fetchData = async () => {
  try {
    loading.value = true;
    const { data } = await getArticleList({
      ...searchForm,
      pageNum: pagination.pageNum,
      pageSize: pagination.pageSize,
    });
    tableData.value = data.records;
    pagination.total = data.total;
  } catch (error) {
    ElMessage.error("获取数据失败");
  } finally {
    loading.value = false;
  }
};

const handleSearch = () => {
  pagination.pageNum = 1;
  fetchData();
};

const handleReset = () => {
  Object.keys(searchForm).forEach((key) => {
    searchForm[key] = "";
  });
  handleSearch();
};

const handleEdit = (row) => {
  // 编辑逻辑
};

const handleDelete = async (row) => {
  try {
    await ElMessageBox.confirm("确定要删除这篇文章吗？", "提示", {
      type: "warning",
    });
    await deleteArticle(row.id);
    ElMessage.success("删除成功");
    fetchData();
  } catch (error) {
    if (error !== "cancel") {
      ElMessage.error("删除失败");
    }
  }
};

// 生命周期
onMounted(() => {
  fetchData();
});
</script>

<style lang="scss" scoped>
.article-list {
  padding: 20px;

  .el-form {
    margin-bottom: 20px;
    padding: 20px;
    background-color: var(--el-bg-color-page);
    border-radius: 4px;
  }

  .el-pagination {
    margin-top: 20px;
    text-align: right;
  }
}
</style>
```

## 最佳实践

1. **组件设计原则**

   - 单一职责：每个组件只负责一个功能
   - 可复用性：通用组件要考虑复用场景
   - 可维护性：代码结构清晰，易于理解

2. **性能优化**

   - 合理使用 `v-show` 和 `v-if`
   - 避免在模板中使用复杂表达式
   - 使用 `key` 优化列表渲染
   - 图片懒加载和预加载

3. **用户体验**

   - 加载状态提示
   - 错误处理和提示
   - 防抖和节流
   - 响应式设计

4. **代码质量**

   - ESLint + Prettier 代码格式化
   - 组件和函数添加注释
   - 使用 TypeScript（推荐）
   - 编写单元测试
   - **🔍 标签闭合检查：修改代码后必须检查所有 HTML 标签是否正确闭合，避免渲染错误**

5. **安全性**
   - 输入验证和过滤
   - XSS 防护
   - CSRF 防护
   - 敏感信息不要暴露在前端
